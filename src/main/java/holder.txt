        // Iterate over all neighbors of the current node the agent is at
        for(Node node : a.currentNode.neighborNodes){
            degsOfBelief.add(Calculations.calcDegOfBelief(a.currentNode, node, a.graph, currentTime));
            degsOfBeliefNodes.add(node);
        }

        // Calculate the entropy and get node with highest degree of belief
        for(int i = 0; i < degsOfBelief.size(); i++){
            entropy += Calculations.calcEntropy(degsOfBelief.get(i));
        }
        // Normalize
        entropy = entropy / (Math.log(a.currentNode.numNeighbors) / Math.log(2));
        entropy = entropy * -1;

        // ***** Print for debugging
        this.printAgentDebugging(a, 2, degsOfBelief, degsOfBeliefNodes);
//        this.printMathDebugging(a.name, degsOfBelief, degsOfBeliefNodes, currentTime, entropy);

        Node goalNode;
        int highestIdx;
        while(true){
            // get the index
            highestIdx = degsOfBelief.indexOf(Collections.max(degsOfBelief));

            // check to see if the node is visitable. If yes, break the loop
            if(degsOfBeliefNodes.get(highestIdx).alreadyDeclared == true){
                // If not able to visit, remove that index from the list and start over.
                degsOfBelief.remove(highestIdx);
                degsOfBeliefNodes.remove(highestIdx);

                // Maybe need to check for empty set after removal -- YES
                // Empty means no nodes can be traveled to, agent does nothing for now
                if(degsOfBelief.isEmpty() || degsOfBeliefNodes.isEmpty()){
                    a.distanceTraveled = 0;
                    a.destNode = null;
                    return;
                }
            }
            else{
                break;
            }
        }
